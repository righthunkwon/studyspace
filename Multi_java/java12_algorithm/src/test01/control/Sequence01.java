package test01.control;

import java.util.Scanner;

import javax.sound.midi.Sequence;

public class Sequence01 {

	/*
		[문제]
		n이하의 수 중에서 3의 배수와 5의 배수가 아닌 수를 출력하시오.
		
		[입력]
		15
		
		[출력]
		1 2 4 7 8 11 13 14
	*/
	public Sequence01() {
		
	}

	public static void sequencePrint(int num) { // static이면 그냥 호출해도 되지만, static이 아니면 객체로 만들어 호출해야 한다.
		for(int i=1; i<=num; i++) { // 1~max
			if(i%3!=0 && i%5!=0) { // 3의 배수도 아니고, 5의 배수도 아닌 수
				System.out.print(i+" ");
			}
		}
	}
	
	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		int max = scan.nextInt();
		sequencePrint(max);
	}

}

	/*
	 	(문제랑은 무관)
	
		패리티 비트(Parity Bit) 오류 검출
			패리티 비트는 저장된 데이터의 1bit 오류를 검출하는 코드 방식입니다.
			패리티 비트에는 홀수(odd, 기수)방식, 짝수(even, 우수)방식이 있습니다.
			홀수 방식의 경우는 데이터의 합이 홀수가 되게 삽입하는 비트가 패리티비트가 되며
			짝수 방식의 경우에는 데이터의 합이 짝수가 되게 비트를 삽입합니다.
			
			컴퓨터의 하드디스크에 데이터는 실질적으로 0과 1 즉 이진수로 변환되어 저장됩니다.
			우리가 평소에 보는 문서파일들이나 게임 프로그램도 내부적으로는 컴퓨터가 인식하는것은 0과 1로 이루어진 데이터들입니다.
			데이터는 기억장치에 특정한 크기단위로 저장되어는데 데이터를 저장 또는 읽어올 때에는 주소를 통해 접근하게 됩니다.
			
			
			case 1) 문제 상황
			
				간단하게 예를 들어보겠습니다.
				120이란 값을 8비트의 공간에 저장했다고 가정합니다.
				그럼 우리가 작성한 이 120이라는 숫자값은 내부적으로 2진수로 바뀌어 기억장치의 특정 주소 위치에 저장됩니다.
				 
				120은 2진수로 1111000입니다.
				그럼 해당 데이터를 저장했을 때 01111000이 저장될 것입니다.
				이때 다음과 같이 1비트가 남게 되는데 왼쪽의 빈 공간은 0으로 채웁니다.
				
				만약 이상태에서 오류로 인해 첫번째 1이 0으로 바뀌어버리면 어떻게 될까요?
				혹은 해당 데이터가 사라져버린다면 어떻게 될까요?
				
				00111000이 되어 값을 읽어올 때에는 56이란 값으로 들어있을 것입니다.
				혹은 이상한 데이터가 되어 아예 읽어올 수도 없게 될 것입니다.
			
			
			case 2) 패리티 비트 적용
			
				이번엔 이 데이터에 짝수 패리티비트를 적용해 보겠습니다.
				이전과 같이 120이라는 값을 이진수로 바꾼 후 1111000을 앞에 채워 넣습니다.
				이번에는 맨 뒤 마지막 비어있는 비트를 패리티 비트로 사용합니다.
				 
				짝수 패리티의 경우 데이터의 합이 짝수가 되게 만들어야 합니다.
				현재 데이터는 1 + 1 + 1 + 1 + 0 + 0 + 0 + 0 으로 짝수입니다.
				그러므로 맨 뒤 패리티 비트는 0이 됩니다.
				
				간단하게 1의 개수가 짝수개이면 패리티비트가 0, 홀수개이면 패리티 비트가 1이 된다고 생각하셔도 됩니다.
				어쨌든 패리티 비트 덕분에 8비트를 모두 조합하면 어떻게 해서든 짝수가 됩니다.
				(데이터가 홀수였다면 패리티에 1이 들어가서 결국 짝수가 됩니다.)
				그럼 이 상태에서 첫번째 1이 오류로 인해 소실된다면 어떻게 될까요?
				
				그렇습니다 소실된다 하더라도 패리티를 포함한 데이터의 합은 짝수이므로 소실된 데이터가 1이라는 것을
				유추할 수 있습니다.
				
				이처럼 패리티비트를 이용하면 1bit의 데이터 오류를 검출할 수 있게됩니다.
				그러나 패리티 비트는 2개의 bit 오류가 발생했을 경우는 검출할 수 없다는 것을 알아두셔야 합니다.

	*/
